# 设计模式

## 设计模式(Design Pattern)是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结，使用设计模式是为了可重用代码、让代码更容易被他人理解并且保证代码可靠性。

### 《设计模式：可复用面向对象软件的基础》一书中所介绍的23种经典设计模式，不过设计模式并不仅仅只有这23种

### GoF 23种设计模式中包含5种创建型设计模式、7种结构型设计模式和11种行为型设计模式

## 创建型模式

### 意义

- 对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。

### 目的

- 为了使软件的结构更加清晰，外界对于这些对象只需要知道它们共同的接口，而不清楚其具体的实现细节，使整个系统的设计更加符合单一职责原则。

### 包含模式

- 简单工厂模式
- 工厂方法模式
- 抽象工厂模式
- 建造者模式
- 原型模式
- 单例模式

## 结构型模式

### 意义

- 结构型模式(Structural Pattern)描述如何将类或者对 象结合在一起形成更大的结构，就像搭积木，可以通过 简单积木的组合形成复杂的、功能更为强大的结构。

### 分类

- 类结构型模式

	- 类结构型模式关心类的组合，由多个类可以组合成一个更大的系统，在类结构型模式中一般只存在继承关系和实现关系。

- 对象结构型模式

	-  对象结构型模式关心类与对象的组合，通过关联关系使得在一 个类中定义另一个类的实例对象，然后通过该对象调用其方法。

### 包含模式

- 适配器模式(Adapter)
- 桥接模式(Bridge)
- 组合模式(Composite)
- 装饰模式(Decorator)
- 外观模式(Facade)
- 代理模式(Proxy)

## 行为型模式

### 行为型模式(Behavioral Pattern)是对在不同的对象之间划分责任和算法的抽象化。

- 通过行为型模式，可以更加清晰地划分类与对象的职责，并研究系统在运行时实例对象 之间的交互。
- 在系统运行时，对象并不是孤立的，它们可以通过相互通信与协作完成某些复杂功能，一个对象在运行时也将影响到其他对象的运行。

### 分类

- 类行为型模式

	- 类的行为型模式使用继承关系在几个类之间分配行为，类行为型模式主要通过多态等方式来分配父类与子类的职责。

- 对象行为型模式

	- 对象的行为型模式则使用对象的聚合关联关系来分配行为，对象行为型模式主要是通过对象关联等方式来分配两个或多个类的职责。根据“合成复用原则”，系统中要尽量使用关联关系来取代继承关系，因此大部分行为型设计模式都属于对象行为型设计模式。

### 包含模式

- 职责链模式(Chain of Responsibility)
- 命令模式(Command)
- 解释器模式(Interpreter)
- 迭代器模式(Iterator)
- 中介者模式(Mediator)
- 观察者模式(Observer)
- 状态模式(State)
- 策略模式(Strategy)

## 面向对象设计原则

### 单一职责原则

- 一个类只负责一个功能领域中的相应职责
- 单一职责原则是实现高内聚、低耦合的指导方针，它是最简单但又最难运用的原则

### 开闭原则

- 软件实体应对扩展开放，而对修改关闭

	- 即软件实体应尽量在不修改原有代码的情况下进行扩展。

- 父类 =new 子类

### 里氏代换原则

- 所有引用基类对象的地方能够透明地使用其子类的对象
- 在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。
- 在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象
- 里氏代换原则是实现开闭原则的重要方式之一

### 依赖倒转原则

- 抽象不应该依赖于细节，细节应该依赖于抽象
- 一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增加的新方法。
- 针对抽象层编程，而将具体类的对象通过依赖注入(DependencyInjection, DI)的方式注入到其他对象中，依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。

	- 构造注入
	- 设值注入（Setter注入）
	- 接口注入

### 接口隔离原则

- 使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。
- 根据接口隔离原则，当一个接口太大时，我们需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。
- 在使用接口隔离原则时，我们需要注意控制接口的粒度，接口不能太小，如果太小会导致系统中接口泛滥，不利于维护；接口也不能太大，太大的接口将违背接口隔离原则，灵活性较差，使用起来很不方便。

### 合成复用原则

- 尽量使用对象组合，而不是继承来达到复用的目的
- 通过组合/聚合关系或通过继承，但首先应该考虑使用组合/聚合，组合/聚合可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少
- 过继承来进行复用的主要问题在于继承复用会破坏系统的封装性，因为继承会将基类的实现细节暴露给子类，由于基类的内部细节通常对子类来说是可见的，所以这种复用又称“白箱”复用，如果基类发生改变，那么子类的实现也不得不发生改变；从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性
- 由于组合或聚合关系可以将已有的对象（也可称为成员对象）纳入到新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能，这样做可以使得成员对象的内部实现细节对于新对象不可见，所以这种复用又称为“黑箱”复用。相对继承关系而言，其耦合度相对较低，成员对象的变化对新对象的影响不大，可以在新对象中根据实际需要有选择性地调用成员对象的操作；合成复用可以在运行时动态进行，新对象可以动态地引用与成员对象类型相同的其他对象。
- 如果两个类之间是“Has-A”的关系应使用组合或聚合，如果是“Is-A”关系可使用继承
- 在实现复用时应该多用关联，少用继承

### 迪米特法则

- 一个软件实体应当尽可能少地与其他实体发生相互作用
- 迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系。
- 定义形式

	- (1) 当前对象本身(this)
	- (2) 以参数形式传入到当前对象方法中的对象；
	- (3) 当前对象的成员对象；
	- (4) 如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友；
	-  (5) 当前对象所创建的对象。

- 在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及；在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限；在类的设计上，只要有可能，一个类型应当设计成不变类；在对其他类的引用上，一个对象对其他对象的引用应当降到最低。
