## 序列化意义

> 序列化： 将数据结构或对象转换成二进制串的过程



> 反序列化：将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程



#### 数据结构和对象：

​	 对于类似Java这种完全面向对象的语言，工程师所操作的一切都是对象（Object），来自于类的实例化。在Java语言中最接近数据结构的概念，就是POJO（Plain Old Java Object） 或者Javabean－－那些只有setter/getter方法的类。

####  二进制串：

> 序列化所生成的二进制串指的是存储在内存中的一块数据。

简单来说序列化就是一种用来处理对象流的机制。

​	所谓对象流也就是将对象的内容进行流化，流的概念这里不用多说(就是I/O)。

​	我们可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间(注：要想将对象传输于网络必须进行流化)！

​	在对对象流进行读写操作时会引发一些问题，而序列化机制正是用来解决这些问题的！

## 序列化协议特性

> 每种序列化协议都有优点和缺点，它们在设计之初有自己独特的应用场景。 在系统设计的过程中，需要考虑序列化需求的方方面面， 综合对比各种序列化协议的特性，最终给出一个折衷的方案。

#### 通用性

 通用性有两个层面的意义：

* 第一、技术层面，序列化协议是否支持跨平台、跨语言。如果不支持，在技术层面上的通用性就大大降低了。

* 第二、流行程度，序列化和反序列化需要多方参与，很少人使用的协议往往意味着昂贵的学习成本；

* 另一方面，流行度低的协议，往往缺乏稳定而成熟的跨语言、跨平台的公共包。

#### 强健性/鲁棒性

 以下两个方面的原因会导致协议不够强健：

* 第一、成熟度不够，一个协议从制定到实施，到最后成熟往往是一个漫长的阶段。协议的强健性依赖于大量而全面的测试，对于致力于提供高质量服务的系统，采用处于测试阶段的序列化协议会带来很高的风险。

* 第二、语言/平台的不公平性。为了支持跨语言、跨平台的功能，序列化协议的制定者需要做大量的工作；但是，当所支持的语言或者平台之间存在难以调和的特性的时候，协议制定者需要做一个艰难的决定--支持更多人使用的语言/平台， 亦或支持更多的语言/平台而放弃某个特性。当协议的制定者决定为某种语言或平台提供更多支持的时候，对于使用者而言，协议的强健性就被牺牲了。

####  可调试性/可读性

* 序列化和反序列化的数据正确性和业务正确性的调试往往需要很长的时间，良好的调试机制会大大提高开发效率。序列化后的二进制串往往不具备人眼可读性，为了验证序列化结果的正确性，写入方不得同时撰写反序列化程序，或提供一个查询平台--这比较费时；

* 另一方面，如果读取方未能成功实现反序列化，这将给问题查找带来了很大的挑战--难以定位是由于自身的反序列化程序的bug所导致还是由于写入方序列化后的错误数据所导致。

对于跨公司间的调试，由于以下原因，问题会显得更严重：

* 第一、支持不到位，跨公司调试在问题出现后可能得不到及时的支持，这大大延长了调试周期。

* 第二、访问限制，调试阶段的查询平台未必对外公开，这增加了读取方的验证难度。

* 如果序列化后的数据人眼可读，这将大大提高调试效率， XML和JSON就具有人眼可读的优点。



## 性能

性能包括两个方面，时间复杂度和空间复杂度：

* 第一、空间开销（Verbosity）， 序列化需要在原有的数据上加上描述字段，以为反序列化解析之用。 如果序列化过程引入的额外开销过高，可能会导致过大的网络，磁盘等各方面的压力。 对于海量分布式存储系统，数据量往往以TB为单位，巨大的的额外空间开销意味着高昂的成本。

* 第二、时间开销（Complexity），复杂的序列化协议会导致较长的解析时间，这可能会使得序列化和反序列化阶段成为整个系统的瓶颈。

#### 可扩展性/兼容性

 移动互联时代，业务系统需求的更新周期变得更快，新的需求不断涌现，而老的系统还是需要继续维护。 如果序列化协议具有良好的可扩展性，支持自动增加新的业务字段，而不影响老的服务，这将大大提供系统的灵活度。

#### 安全性/访问限制

在序列化选型的过程中，安全性的考虑往往发生在跨局域网访问的场景。 当通讯发生在公司之间或者跨机房的时候，出于安全的考虑，对于跨局域网的访问往往被限制为基于HTTP/HTTPS的80和443端口。

 如果使用的序列化协议没有兼容而成熟的HTTP传输层框架支持，可能会导致以下三种结果之一：

* 第一、因为访问限制而降低服务可用性。

* 第二、被迫重新实现安全协议而导致实施成本大大提高。

* 第三、开放更多的防火墙端口和协议访问，而牺牲安全性。

所有类都进行实例化是不建议的，存在版本差异，在多分布式系统传输时会产生差异